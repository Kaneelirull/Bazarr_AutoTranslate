import requests
import time  # Import the time module
from urllib.parse import quote  # Import for URL encoding
from concurrent.futures import ThreadPoolExecutor, as_completed

# Set how many translations to run in parallel
MAX_PARALLEL_TRANSLATIONS = 3

# Bazarr Configuration
BAZARR_HOSTNAME = "Localhost:1337"  # Update your hostname here
BAZARR_APIKEY = "BAZARR_APIKEY"

# Language preferences
FIRST_LANG = "et"  # Primary target language
SECOND_LANG = "sv"  # Secondary target language (optional)

HEADERS = {"Accept": "application/json", "X-API-KEY": BAZARR_APIKEY}


def get_api_url(endpoint):
    """Construct the full API URL for a given endpoint."""
    return f"http://{BAZARR_HOSTNAME}/api/{endpoint}"


def fetch_items(item_type, wanted_endpoint):
    """Fetch the list of wanted episodes or movies."""
    url = get_api_url(wanted_endpoint)
    print(f"[DEBUG] Fetching items from URL: {url}")
    try:
        response = requests.get(url, headers=HEADERS)
        print(f"[DEBUG] Response status code: {response.status_code}")
        if response.status_code == 200:
            items = response.json().get("data", [])
            print(f"[INFO] Fetched {len(items)} {item_type}(s).")
            return items
        else:
            print(f"[WARNING] Failed to fetch {item_type}: {response.status_code}")
            print(f"[DEBUG] Response text: {response.text}")
            return []
    except requests.RequestException as e:
        print(f"[ERROR] Exception occurred while fetching {item_type}: {e}")
        return []


def download_subtitles(item_type, item_id, params_field, language="en", series_id=None):
    """
    Download subtitles for a given item (episode or movie) in the specified language.
    Adds seriesid for episodes if required.
    """
    url = get_api_url(f"{item_type}/subtitles")
    
    # Construct the query parameters dynamically
    if item_type == "episodes" and series_id:  # Episodes require 'seriesid' and 'episodeid'
        query_params = f"seriesid={series_id}&{params_field}={item_id}&language={language}&forced=false&hi=false"
    else:  # Movies only require 'radarrid'
        query_params = f"{params_field}={item_id}&language={language}&forced=false&hi=false"
    
    constructed_url = f"{url}?{query_params}"

    print(f"[DEBUG] Attempting to download {language} subtitles from URL: {constructed_url}")
    try:
        response = requests.patch(constructed_url, headers=HEADERS)
        print(f"[DEBUG] Response status code: {response.status_code}")
        if response.status_code == 204:
            print(f"[INFO] Subtitles in language '{language}' successfully downloaded for {item_type} (ID: {item_id}).")
            return True
        else:
            print(f"[WARNING] Failed to download subtitles in language '{language}'. Response Code: {response.status_code}")
            print(f"[DEBUG] Response text: {response.text}")
            return False
    except requests.RequestException as e:
        print(f"[ERROR] Exception occurred while trying to download subtitles in language '{language}': {e}")
        return False


def fetch_subtitle_path(item_type, item_id, params_field):
    """Retrieve the path of English subtitles for a given item and URL encode it."""
    url = get_api_url(item_type)
    constructed_url = f"{url}?{params_field}%5B%5D={item_id}"
    print(f"[DEBUG] Fetching subtitle path from URL: {constructed_url}")
    try:
        response = requests.get(constructed_url, headers=HEADERS)
        print(f"[DEBUG] Response status code: {response.status_code}")
        if response.status_code == 200:
            history = response.json()
            for item in history["data"]:
                if "subtitles" in item:
                    for subtitle in item["subtitles"]:
                        if subtitle.get("code2") == "en":  # Look for English subtitles
                            raw_path = subtitle["path"]
                            encoded_path = quote(raw_path, safe="")  # URL encode the path
                            print(f"[INFO] Found and URL-encoded subtitle path:\n - Raw: {raw_path}\n - Encoded: {encoded_path}")
                            return encoded_path
        else:
            print(f"[WARNING] Failed to fetch subtitle path. Response Code: {response.status_code}")
            print(f"[DEBUG] Response text: {response.text}")
    except requests.RequestException as e:
        print(f"[ERROR] Exception occurred while fetching subtitle path: {e}")
    return None


def translate_subtitle(item_type, item_id, subs_path, target_lang, params_field, series_id=None):
    """Translate subtitles to the specified target language with retry mechanism for status code 500."""
    if not target_lang:
        print(f"[DEBUG] Target language not specified. Skipping translation for item_type: {item_type}, item_id: {item_id}.")
        return False

    # Convert item_type to singular form for the API call
    singular_item_type = "movie" if item_type == "movies" else "episode" if item_type == "episodes" else item_type

    # Construct the translation URL
    url = get_api_url("subtitles")
    constructed_url = (
        f"{url}?action=translate&language={target_lang}&path={subs_path}&type={singular_item_type}&id={item_id}&forced=false&hi=false"
    )

    # Additional debug information
    print(f"[DEBUG] translate_subtitle called with:")
    print(f"    - item_type: {item_type}")
    print(f"    - singular_item_type: {singular_item_type}")
    print(f"    - item_id: {item_id}")
    print(f"    - subs_path (URL-encoded): {subs_path}")
    print(f"    - target_lang: {target_lang}")
    print(f"    - Constructed URL: {constructed_url}")

    try:
        # Start timing
        start_time = time.time()
        print(f"[DEBUG] Sending PATCH request to translate subtitles.")

        # Sending HTTP PATCH request with a timeout of 1200 seconds
        response = requests.patch(constructed_url, headers=HEADERS, timeout=1200)

        # End timing
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"[DEBUG] Received PATCH response with status: {response.status_code}")
        print(f"[INFO] Time taken for API request: {elapsed_time:.2f} seconds")
        
        if response.status_code == 204:
            print(f"[INFO] Subtitles translated successfully to {target_lang} for {singular_item_type} (ID: {item_id}).")
            return True
        elif response.status_code == 500:
            print(f"[WARNING] Received status code 500 when translating subtitles to {target_lang}. Retrying...")

            # Retry mechanism: redownload "en" subtitles and retry translation
            if download_subtitles(item_type, item_id, params_field, language="en", series_id=series_id):
                print(f"[INFO] Re-downloaded English subtitles for {singular_item_type} (ID: {item_id}).")
                new_subs_path = fetch_subtitle_path(item_type, item_id, params_field)
                if new_subs_path:
                    # Retry translation with the new subtitle path
                    retry_url = (
                        f"{url}?action=translate&language={target_lang}&path={new_subs_path}&type={singular_item_type}&id={item_id}&forced=false&hi=false"
                    )
                    
                    # Start timing for the retry request
                    retry_start_time = time.time()
                    print(f"[DEBUG] Retry translation using new subtitle path: {retry_url}")
                    retry_response = requests.patch(retry_url, headers=HEADERS, timeout=1200)
                    
                    # End timing for the retry request
                    retry_end_time = time.time()
                    retry_elapsed_time = retry_end_time - retry_start_time
                    print(f"[DEBUG] Retry response status code: {retry_response.status_code}")
                    print(f"[INFO] Time taken for retry API request: {retry_elapsed_time:.2f} seconds")
                    
                    if retry_response.status_code == 204:
                        print(f"[INFO] Subtitles successfully translated to {target_lang} after retry for {singular_item_type} (ID: {item_id}).")
                        return True
                    else:
                        print(f"[WARNING] Retry translation failed. Response Code: {retry_response.status_code}")
                        print(f"[DEBUG] Retry response text: {retry_response.text}")
                else:
                    print(f"[ERROR] Failed to fetch the new English subtitles path for retry.")
            else:
                print(f"[ERROR] Could not redownload English subtitles for {singular_item_type} (ID: {item_id}).")

        # Handle other non-success status codes
        print(f"[WARNING] Failed to translate subtitles. Response Code: {response.status_code}")
        print(f"[DEBUG] Response text: {response.text}")
        return False
    except requests.Timeout:
        print(f"[ERROR] Timeout occurred while translating subtitles for {singular_item_type} (ID: {item_id}).")
        return False
    except requests.RequestException as e:
        print(f"[ERROR] Exception occurred while translating subtitles for {singular_item_type} (ID: {item_id}): {e}")
        return False


def process_item(item, item_type, id_field, params_field):
    """Process a single item: Determine missing subtitles, download, and translate."""

    # ANSI Escape Color Codes
    GREEN = "\033[92m"   # Bright Green for [INFO]
    YELLOW = "\033[93m"  # Bright Yellow for [DEBUG]
    RED = "\033[91m"     # Bright Red for [WARNING]
    BOLD_RED = "\033[1;91m"  # Bold Bright Red for [ERROR]
    RESET = "\033[0m"    # Reset to default terminal color

    item_id = item[id_field]
    item_name = item.get("seriesTitle", item.get("title", "Unknown Item"))
    series_id = item.get("sonarrSeriesId") if item_type == "episodes" else None  # Extract 'seriesid' for episodes

    # [INFO] Start processing
    print("\n")
    print("\n")
    print(f"{GREEN}---------------------------------------------------------------------------------------------------")
    print(f"{GREEN}[INFO] Processing: {item_name} (ID: {item_id}){RESET}")
    print(f"{GREEN}---------------------------------------------------------------------------------------------------")

    # Check which languages are missing
    missing_subtitles = item.get("missing_subtitles", [])
    missing_languages = [lang["code2"] for lang in missing_subtitles]  # Extract 'code2' for missing languages
    print(f"{YELLOW}[DEBUG] Missing languages for {item_name}: {', '.join(missing_languages)}{RESET}")

    # Step 1: Download English subtitles (required for translating)
    if "en" in missing_languages:
        if download_subtitles(item_type, item_id, params_field, language="en", series_id=series_id):
            print(f"{GREEN}[INFO] English subtitles downloaded for {item_name}.{RESET}")
        else:
            print(f"{RED}[WARNING] Failed to download English subtitles for {item_name}. Skipping...{RESET}")
            return
    else:
        print(f"{GREEN}[INFO] English subtitles already available for {item_name}.{RESET}")

    # Step 2: Retrieve the path of the downloaded English subtitles
    subs_path = fetch_subtitle_path(item_type, item_id, params_field)
    if not subs_path:
        print(f"{RED}[WARNING] Failed to retrieve English subtitles path for {item_name}. Skipping...{RESET}")
        return

    # Step 3: Translate to the first preferred language if it's missing
    if FIRST_LANG in missing_languages:
        if translate_subtitle(item_type, item_id, subs_path, FIRST_LANG, params_field, series_id=series_id):
            print(f"{GREEN}[INFO] Translated {item_name} subtitles to {FIRST_LANG}.{RESET}")
        else:
            print(f"{RED}[WARNING] Failed to translate {item_name} subtitles to {FIRST_LANG}.{RESET}")
    else:
        print(f"{GREEN}[INFO] Subtitles in {FIRST_LANG} already exist for {item_name}.{RESET}")

    # Step 4: Translate to the second preferred language if it's missing
    if SECOND_LANG and SECOND_LANG in missing_languages:
        if translate_subtitle(item_type, item_id, subs_path, SECOND_LANG, params_field, series_id=series_id):
            print(f"{GREEN}[INFO] Translated {item_name} subtitles to {SECOND_LANG}.{RESET}")
        else:
            print(f"{RED}[WARNING] Failed to translate {item_name} subtitles to {SECOND_LANG}.{RESET}")
    elif SECOND_LANG:
        print(f"{GREEN}[INFO] Subtitles in {SECOND_LANG} already exist for {item_name}.{RESET}")


def process_items(item_type, wanted_endpoint, id_field, params_field):
    """Process all wanted items of a specified type (episodes or movies) with parallel processing."""
    items = fetch_items(item_type, wanted_endpoint)
    if not items:
        print(f"[INFO] No {item_type} items found to process.")
        return

    # Use ThreadPoolExecutor for parallel processing
    with ThreadPoolExecutor(max_workers=MAX_PARALLEL_TRANSLATIONS) as executor:
        # Submit tasks to ThreadPoolExecutor
        future_to_item = {
            executor.submit(process_item, item, item_type, id_field, params_field): item for item in items
        }

        # As each task completes, log the results or handle exceptions
        for future in as_completed(future_to_item):
            item = future_to_item[future]
            item_name = item.get("seriesTitle", item.get("title", "Unknown Item"))
            try:
                # This will raise an exception if the task threw one
                future.result()
                print(f"[INFO] Successfully finished processing item: {item_name}")
            except Exception as e:
                print(f"[ERROR] Failed to process item: {item_name}. Exception: {e}")


def translate_episode_subs():
    """Translate subtitles for all wanted episodes."""
    process_items(
        item_type="episodes",
        wanted_endpoint="episodes/wanted?start=0&length=-1",
        id_field="sonarrEpisodeId",
        params_field="episodeid",
    )


def translate_movie_subs():
    """Translate subtitles for all wanted movies."""
    process_items(
        item_type="movies",
        wanted_endpoint="movies/wanted?start=0&length=-1",
        id_field="radarrId",
        params_field="radarrid",
    )


def main():
    print("[INFO] Starting subtitle processing...")
    translate_movie_subs()
    translate_episode_subs()
    print("[INFO] Subtitle processing completed.")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[ERROR] Unexpected error: {e}")
